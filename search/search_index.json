{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Sparse vectors optimized for memory and NumPy integrations.</p> <p><code>numpy</code> handles densely populated n-dimemsional arrays. <code>scipy.sparse</code> handles sparsely populated 2-dimensional arrays, i.e., matrices. What's missing from the ecosystem is sparsely populated 1-dimensional arrays, i.e., vectors.</p> NumPy Python Spector 1-dim bool <code>numpy.array</code> <code>set[int]</code> <code>spector.indices</code> 1-dim float <code>numpy.array</code> <code>dict[int, float]</code> <code>spector.vector</code> <code>scipy.sparse.dok_matrix</code> <code>dict[int, dict[int, float]]</code> <code>spector.matrix</code> <p>Indices and vectors are implemented in Cython as hash sets and maps. All native operations are optimized and release the GIL.</p> <ul> <li>conversion between sparse <code>numpy</code> arrays</li> <li>conversion between dense <code>numpy</code> arrays</li> <li>binary set operations</li> <li>binary math operations</li> <li><code>map</code>, <code>filter</code>, and <code>reduce</code> operations with <code>numpy</code> universal functions</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#indices","title":"indices","text":"<p>A sparse boolean array with a set interface.</p> <pre><code>&gt;&gt;&gt; from spector import indices\n&gt;&gt;&gt; ind = indices([0, 2])\n&gt;&gt;&gt; ind\nindices([2 0])\n&gt;&gt;&gt; 1 in ind\nFalse\n&gt;&gt;&gt; ind.add(1)\nTrue\n&gt;&gt;&gt; ind.todense()\narray([ True,  True,  True])\n&gt;&gt;&gt; ind.fromdense(_)\nindices([2 1 0])\n</code></pre>"},{"location":"#vector","title":"vector","text":"<p>A sparse float array with a mapping interface.</p> <pre><code>&gt;&gt;&gt; from spector import vector\n&gt;&gt;&gt; vec = vector({0: 1.0, 2: 2.0, 4: 1.0})\n&gt;&gt;&gt; vec\nvector([4 2 0], [1. 2. 1.])\n&gt;&gt;&gt; vec[2] += 1.0\n&gt;&gt;&gt; vec[2]\n3.0\n&gt;&gt;&gt; vec.todense()\narray([1., 0., 3., 0., 1.])\n&gt;&gt;&gt; vector.fromdense(_)\nvector([4 2 0], [1. 3. 1.])\n&gt;&gt;&gt; vec.sum()\n5.0\n&gt;&gt;&gt; vec + vec\nvector([0 2 4], [2. 6. 2.])\n</code></pre> <p>Vectors support math operations with scalars, and with vectors if the set method is unambiguous.</p> vector operation set method ufunc <code>+</code> union add <code>*</code> intersection multiply <code>-</code> subtract <code>/</code> true_divide <code>**</code> power <code>\\|</code> union max <code>&amp;</code> intersection min <code>^</code> symmetric_difference <code>difference</code> difference"},{"location":"#matrix","title":"matrix","text":"<p>A mapping of keys to vectors.</p> <pre><code>&gt;&gt;&gt; from spector import matrix\n&gt;&gt;&gt; mat = matrix({0: {1: 2.0}})\n&gt;&gt;&gt; mat\nmatrix(&lt;class 'spector.vector.vector'&gt;, {0: vector([1], [2.])})\n&gt;&gt;&gt; mat.row, mat.col, mat.data\n(array([0]), array([1]), array([2.]))\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>% pip install spector\n</code></pre>"},{"location":"#tests","title":"Tests","text":"<p>100% branch coverage.</p> <pre><code>% pytest [--cov]\n</code></pre>"},{"location":"examples/","title":"Examples","text":"In\u00a0[1]: Copied! <pre>import numpy as np\n\nfrom spector import indices\n\nind = indices([0, 2])\nind\n</pre> import numpy as np  from spector import indices  ind = indices([0, 2]) ind Out[1]: <pre>indices([2 0])</pre> In\u00a0[2]: Copied! <pre>np.array(ind)\n</pre> np.array(ind) Out[2]: <pre>array([2, 0])</pre> In\u00a0[3]: Copied! <pre>1 in ind\n</pre> 1 in ind Out[3]: <pre>False</pre> In\u00a0[4]: Copied! <pre>ind.add(1)\n</pre> ind.add(1) Out[4]: <pre>True</pre> In\u00a0[5]: Copied! <pre>ind.todense()\n</pre> ind.todense() Out[5]: <pre>array([ True,  True,  True])</pre> In\u00a0[6]: Copied! <pre>indices.fromdense([True, False, True])\n</pre> indices.fromdense([True, False, True]) Out[6]: <pre>indices([2 0])</pre> In\u00a0[7]: Copied! <pre>from spector import vector\n\nvec = vector({0: 1.0, 2: 2.0, 4: 1.0})\nvec\n</pre> from spector import vector  vec = vector({0: 1.0, 2: 2.0, 4: 1.0}) vec Out[7]: <pre>vector([4 2 0], [1. 2. 1.])</pre> In\u00a0[8]: Copied! <pre>np.array(vec)\n</pre> np.array(vec) Out[8]: <pre>array([1., 2., 1.])</pre> In\u00a0[9]: Copied! <pre>vec[2] += 1.0\nvec[2]\n</pre> vec[2] += 1.0 vec[2] Out[9]: <pre>3.0</pre> In\u00a0[10]: Copied! <pre>vec.sum()\n</pre> vec.sum() Out[10]: <pre>5.0</pre> In\u00a0[11]: Copied! <pre>vec.todense()\n</pre> vec.todense() Out[11]: <pre>array([1., 0., 3., 0., 1.])</pre> In\u00a0[12]: Copied! <pre>vector.fromdense([1, 0, 2, 0, 1])\n</pre> vector.fromdense([1, 0, 2, 0, 1]) Out[12]: <pre>vector([4 2 0], [1. 2. 1.])</pre> In\u00a0[13]: Copied! <pre>from spector import matrix\n\nmat = matrix({0: {1: 2.0}})\nmat\n</pre> from spector import matrix  mat = matrix({0: {1: 2.0}}) mat Out[13]: <pre>matrix(spector.vector.vector, {0: vector([1], [2.])})</pre> In\u00a0[14]: Copied! <pre>mat.row, mat.col, mat.data\n</pre> mat.row, mat.col, mat.data Out[14]: <pre>(array([0]), array([1]), array([2.]))</pre>"},{"location":"examples/#examples","title":"Examples\u00b6","text":""},{"location":"examples/#indices","title":"indices\u00b6","text":""},{"location":"examples/#vector","title":"vector\u00b6","text":""},{"location":"examples/#matrix","title":"matrix\u00b6","text":""},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#spector.indices","title":"<code>spector.indices</code>","text":"<p>A sparse boolean array, i.e., set of indices.</p> <p>Provides a memory efficient set interface, with optimized conversion between numpy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable</code> <p>optional iterable of keys</p> required"},{"location":"reference/#spector.indices.__doc__","title":"<code>__doc__ = 'A sparse boolean array, i.e., set of indices.\\n\\n    Provides a memory efficient set interface, with optimized conversion between numpy arrays.\\n\\n    Args:\\n        keys (Iterable): optional iterable of keys\\n    '</code>  <code>class-attribute</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#spector.indices.__pyx_vtable__","title":"<code>__pyx_vtable__ = &lt;capsule object NULL at 0x7fc0553baee0&gt;</code>  <code>class-attribute</code>","text":"<p>Capsule objects let you wrap a C \"void *\" pointer in a Python object.  They're a way of passing data through the Python interpreter without creating your own custom type.</p> <p>Capsules are used for communication between extension modules. They provide a way for an extension module to export a C interface to other extension modules, so that extension modules can use the Python import mechanism to link to one another.</p>"},{"location":"reference/#spector.indices.__array__","title":"<code>__array__(dtype=int64, copy=None)</code>  <code>method descriptor</code>","text":"<p>Return keys as numpy array.</p>"},{"location":"reference/#spector.indices.__contains__","title":"<code>__contains__(key)</code>  <code>method descriptor</code>","text":"<p>Return bool(key in self).</p>"},{"location":"reference/#spector.indices.__eq__","title":"<code>__eq__(value)</code>  <code>method descriptor</code>","text":"<p>Return self==value.</p>"},{"location":"reference/#spector.indices.__ge__","title":"<code>__ge__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&gt;=value.</p>"},{"location":"reference/#spector.indices.__gt__","title":"<code>__gt__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&gt;value.</p>"},{"location":"reference/#spector.indices.__init__","title":"<code>__init__(*args, **kwargs)</code>  <code>method descriptor</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"reference/#spector.indices.__ior__","title":"<code>__ior__(value)</code>  <code>method descriptor</code>","text":"<p>Return self|=value.</p>"},{"location":"reference/#spector.indices.__isub__","title":"<code>__isub__(value)</code>  <code>method descriptor</code>","text":"<p>Return self-=value.</p>"},{"location":"reference/#spector.indices.__iter__","title":"<code>__iter__()</code>  <code>method descriptor</code>","text":"<p>Implement iter(self).</p>"},{"location":"reference/#spector.indices.__ixor__","title":"<code>__ixor__(value)</code>  <code>method descriptor</code>","text":"<p>Return self^=value.</p>"},{"location":"reference/#spector.indices.__le__","title":"<code>__le__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&lt;=value.</p>"},{"location":"reference/#spector.indices.__len__","title":"<code>__len__()</code>  <code>method descriptor</code>","text":"<p>Return len(self).</p>"},{"location":"reference/#spector.indices.__lt__","title":"<code>__lt__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&lt;value.</p>"},{"location":"reference/#spector.indices.__matmul__","title":"<code>__matmul__()</code>  <code>method descriptor</code>","text":"<p>Return binary dot product, i.e., intersection count.</p>"},{"location":"reference/#spector.indices.__ne__","title":"<code>__ne__(value)</code>  <code>method descriptor</code>","text":"<p>Return self!=value.</p>"},{"location":"reference/#spector.indices.__new__","title":"<code>__new__(*args, **kwargs)</code>  <code>builtin</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"reference/#spector.indices.__rand__","title":"<code>__rand__(value)</code>  <code>method descriptor</code>","text":"<p>Return value&amp;self.</p>"},{"location":"reference/#spector.indices.__repr__","title":"<code>__repr__()</code>  <code>method descriptor</code>","text":"<p>Return repr(self).</p>"},{"location":"reference/#spector.indices.__rmatmul__","title":"<code>__rmatmul__(value)</code>  <code>method descriptor</code>","text":"<p>Return value@self.</p>"},{"location":"reference/#spector.indices.__ror__","title":"<code>__ror__(value)</code>  <code>method descriptor</code>","text":"<p>Return value|self.</p>"},{"location":"reference/#spector.indices.__rsub__","title":"<code>__rsub__(value)</code>  <code>method descriptor</code>","text":"<p>Return value-self.</p>"},{"location":"reference/#spector.indices.__rxor__","title":"<code>__rxor__(value)</code>  <code>method descriptor</code>","text":"<p>Return value^self.</p>"},{"location":"reference/#spector.indices.add","title":"<code>add(key)</code>  <code>method descriptor</code>","text":"<p>Add an index key.</p>"},{"location":"reference/#spector.indices.clear","title":"<code>clear()</code>  <code>method descriptor</code>","text":"<p>Remove all indices.</p>"},{"location":"reference/#spector.indices.difference","title":"<code>difference(*others)</code>  <code>method descriptor</code>","text":"<p>Return the difference of sets as a new set.</p>"},{"location":"reference/#spector.indices.discard","title":"<code>discard(key)</code>  <code>method descriptor</code>","text":"<p>Remove an index key, if present.</p>"},{"location":"reference/#spector.indices.dot","title":"<code>dot(*others)</code>  <code>method descriptor</code>","text":"<p>Return the intersection count of sets.</p>"},{"location":"reference/#spector.indices.fromdense","title":"<code>fromdense(values)</code>  <code>classmethod</code>","text":"<p>Return indices from a dense array representation.</p>"},{"location":"reference/#spector.indices.intersection","title":"<code>intersection(*others)</code>  <code>method descriptor</code>","text":"<p>Return the intersection of sets as a new set.</p>"},{"location":"reference/#spector.indices.isdisjoint","title":"<code>isdisjoint(other)</code>  <code>method descriptor</code>","text":"<p>Return whether two indices have a null intersection.</p>"},{"location":"reference/#spector.indices.todense","title":"<code>todense(minlength=0, dtype=bool)</code>  <code>method descriptor</code>","text":"<p>Return a dense array representation of indices.</p>"},{"location":"reference/#spector.indices.union","title":"<code>union(*others)</code>  <code>method descriptor</code>","text":"<p>Return the union of sets as a new set.</p>"},{"location":"reference/#spector.indices.update","title":"<code>update(*others)</code>  <code>method descriptor</code>","text":"<p>Update from indices, arrays, or iterables.</p>"},{"location":"reference/#spector.vector.vector","title":"<code>spector.vector.vector</code>","text":"<p>A sparse array of index keys mapped to numeric values.</p> <p>Provides a memory efficient Counter interface, with optimized conversion between numpy arrays.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable[int]</code> <p>optional iterable of keys</p> required <code>values</code> <p>optional scalar or iterable of values</p> required"},{"location":"reference/#spector.vector.vector.__doc__","title":"<code>__doc__ = 'A sparse array of index keys mapped to numeric values.\\n\\n    Provides a memory efficient Counter interface, with optimized conversion between numpy arrays.\\n\\n    Args:\\n        keys (Iterable[int]): optional iterable of keys\\n        values: optional scalar or iterable of values\\n    '</code>  <code>class-attribute</code>","text":"<p>str(object='') -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p> <p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.str() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to 'strict'.</p>"},{"location":"reference/#spector.vector.vector.__pyx_vtable__","title":"<code>__pyx_vtable__ = &lt;capsule object NULL at 0x7fc055405e30&gt;</code>  <code>class-attribute</code>","text":"<p>Capsule objects let you wrap a C \"void *\" pointer in a Python object.  They're a way of passing data through the Python interpreter without creating your own custom type.</p> <p>Capsules are used for communication between extension modules. They provide a way for an extension module to export a C interface to other extension modules, so that extension modules can use the Python import mechanism to link to one another.</p>"},{"location":"reference/#spector.vector.vector.__abs__","title":"<code>__abs__()</code>  <code>method descriptor</code>","text":"<p>abs(self)</p>"},{"location":"reference/#spector.vector.vector.__contains__","title":"<code>__contains__(key)</code>  <code>method descriptor</code>","text":"<p>Return bool(key in self).</p>"},{"location":"reference/#spector.vector.vector.__delitem__","title":"<code>__delitem__(key)</code>  <code>method descriptor</code>","text":"<p>Delete self[key].</p>"},{"location":"reference/#spector.vector.vector.__eq__","title":"<code>__eq__(value)</code>  <code>method descriptor</code>","text":"<p>Return self==value.</p>"},{"location":"reference/#spector.vector.vector.__ge__","title":"<code>__ge__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&gt;=value.</p>"},{"location":"reference/#spector.vector.vector.__getitem__","title":"<code>__getitem__(key)</code>  <code>method descriptor</code>","text":"<p>Return self[key].</p>"},{"location":"reference/#spector.vector.vector.__gt__","title":"<code>__gt__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&gt;value.</p>"},{"location":"reference/#spector.vector.vector.__iadd__","title":"<code>__iadd__(value)</code>  <code>method descriptor</code>","text":"<p>Return self+=value.</p>"},{"location":"reference/#spector.vector.vector.__imul__","title":"<code>__imul__(value)</code>  <code>method descriptor</code>","text":"<p>Return self*=value.</p>"},{"location":"reference/#spector.vector.vector.__init__","title":"<code>__init__(*args, **kwargs)</code>  <code>method descriptor</code>","text":"<p>Initialize self.  See help(type(self)) for accurate signature.</p>"},{"location":"reference/#spector.vector.vector.__ior__","title":"<code>__ior__(value)</code>  <code>method descriptor</code>","text":"<p>Return self|=value.</p>"},{"location":"reference/#spector.vector.vector.__ipow__","title":"<code>__ipow__(value)</code>  <code>method descriptor</code>","text":"<p>Return self**=value.</p>"},{"location":"reference/#spector.vector.vector.__isub__","title":"<code>__isub__(value)</code>  <code>method descriptor</code>","text":"<p>Return self-=value.</p>"},{"location":"reference/#spector.vector.vector.__iter__","title":"<code>__iter__()</code>  <code>method descriptor</code>","text":"<p>Implement iter(self).</p>"},{"location":"reference/#spector.vector.vector.__itruediv__","title":"<code>__itruediv__(value)</code>  <code>method descriptor</code>","text":"<p>Return self/=value.</p>"},{"location":"reference/#spector.vector.vector.__ixor__","title":"<code>__ixor__(value)</code>  <code>method descriptor</code>","text":"<p>Return self^=value.</p>"},{"location":"reference/#spector.vector.vector.__le__","title":"<code>__le__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&lt;=value.</p>"},{"location":"reference/#spector.vector.vector.__len__","title":"<code>__len__()</code>  <code>method descriptor</code>","text":"<p>Return len(self).</p>"},{"location":"reference/#spector.vector.vector.__lt__","title":"<code>__lt__(value)</code>  <code>method descriptor</code>","text":"<p>Return self&lt;value.</p>"},{"location":"reference/#spector.vector.vector.__matmul__","title":"<code>__matmul__()</code>  <code>method descriptor</code>","text":"<p>Return vector dot product.</p>"},{"location":"reference/#spector.vector.vector.__ne__","title":"<code>__ne__(value)</code>  <code>method descriptor</code>","text":"<p>Return self!=value.</p>"},{"location":"reference/#spector.vector.vector.__neg__","title":"<code>__neg__()</code>  <code>method descriptor</code>","text":"<p>-self</p>"},{"location":"reference/#spector.vector.vector.__new__","title":"<code>__new__(*args, **kwargs)</code>  <code>builtin</code>","text":"<p>Create and return a new object.  See help(type) for accurate signature.</p>"},{"location":"reference/#spector.vector.vector.__pow__","title":"<code>__pow__(value, mod=None)</code>  <code>method descriptor</code>","text":"<p>Return pow(self, value, mod).</p>"},{"location":"reference/#spector.vector.vector.__rand__","title":"<code>__rand__(value)</code>  <code>method descriptor</code>","text":"<p>Return value&amp;self.</p>"},{"location":"reference/#spector.vector.vector.__repr__","title":"<code>__repr__()</code>  <code>method descriptor</code>","text":"<p>Return repr(self).</p>"},{"location":"reference/#spector.vector.vector.__rmatmul__","title":"<code>__rmatmul__(value)</code>  <code>method descriptor</code>","text":"<p>Return value@self.</p>"},{"location":"reference/#spector.vector.vector.__ror__","title":"<code>__ror__(value)</code>  <code>method descriptor</code>","text":"<p>Return value|self.</p>"},{"location":"reference/#spector.vector.vector.__rpow__","title":"<code>__rpow__(value, mod=None)</code>  <code>method descriptor</code>","text":"<p>Return pow(value, self, mod).</p>"},{"location":"reference/#spector.vector.vector.__rxor__","title":"<code>__rxor__(value)</code>  <code>method descriptor</code>","text":"<p>Return value^self.</p>"},{"location":"reference/#spector.vector.vector.__setitem__","title":"<code>__setitem__(key, value)</code>  <code>method descriptor</code>","text":"<p>Set self[key] to value.</p>"},{"location":"reference/#spector.vector.vector.argmax","title":"<code>argmax(**kwargs)</code>  <code>method descriptor</code>","text":"<p>Return key with maximum value.</p>"},{"location":"reference/#spector.vector.vector.argmin","title":"<code>argmin(**kwargs)</code>  <code>method descriptor</code>","text":"<p>Return key with minimum value.</p>"},{"location":"reference/#spector.vector.vector.argpartition","title":"<code>argpartition(kth, **kwargs)</code>  <code>method descriptor</code>","text":"<p>Return keys partitioned by values.</p>"},{"location":"reference/#spector.vector.vector.argsort","title":"<code>argsort(**kwargs)</code>  <code>method descriptor</code>","text":"<p>Return keys sorted by values.</p>"},{"location":"reference/#spector.vector.vector.clear","title":"<code>clear()</code>  <code>method descriptor</code>","text":"<p>Remove all items.</p>"},{"location":"reference/#spector.vector.vector.difference","title":"<code>difference(*others)</code>  <code>method descriptor</code>","text":"<p>Provisional set difference; return vector without keys.</p>"},{"location":"reference/#spector.vector.vector.equal","title":"<code>equal(other)</code>  <code>method descriptor</code>","text":"<p>Return whether vectors are equal as scalar bool; == is element-wise.</p>"},{"location":"reference/#spector.vector.vector.filter","title":"<code>filter(ufunc, *args, **kwargs)</code>  <code>method descriptor</code>","text":"<p>Return element-wise array of keys from applying predicate across vectors.</p>"},{"location":"reference/#spector.vector.vector.fromdense","title":"<code>fromdense(values)</code>  <code>classmethod</code>","text":"<p>Return vector from a dense array representation.</p>"},{"location":"reference/#spector.vector.vector.items","title":"<code>items()</code>  <code>method descriptor</code>","text":"<p>Return zipped keys and values.</p>"},{"location":"reference/#spector.vector.vector.keys","title":"<code>keys()</code>  <code>method descriptor</code>","text":"<p>Return keys as numpy array.</p>"},{"location":"reference/#spector.vector.vector.map","title":"<code>map(ufunc, *args, **kwargs)</code>  <code>method descriptor</code>","text":"<p>Return element-wise array of values from applying function across vectors.</p>"},{"location":"reference/#spector.vector.vector.max","title":"<code>max(initial=None, **kwargs)</code>  <code>method descriptor</code>","text":"<p>Return maximum value.</p>"},{"location":"reference/#spector.vector.vector.maximum","title":"<code>maximum(value)</code>  <code>method descriptor</code>","text":"<p>Return element-wise maximum vector.</p>"},{"location":"reference/#spector.vector.vector.min","title":"<code>min(initial=None, **kwargs)</code>  <code>method descriptor</code>","text":"<p>Return minimum value.</p>"},{"location":"reference/#spector.vector.vector.minimum","title":"<code>minimum(value)</code>  <code>method descriptor</code>","text":"<p>Return element-wise minimum vector.</p>"},{"location":"reference/#spector.vector.vector.sum","title":"<code>sum(initial=0.0, dtype=float, **kwargs)</code>  <code>method descriptor</code>","text":"<p>Return sum of values.</p>"},{"location":"reference/#spector.vector.vector.todense","title":"<code>todense(minlength=0, dtype=float)</code>  <code>method descriptor</code>","text":"<p>Return a dense array representation of vector.</p>"},{"location":"reference/#spector.vector.vector.update","title":"<code>update(keys, values=1.0)</code>  <code>method descriptor</code>","text":"<p>Update from vector, arrays, mapping, or keys with scalar.</p>"},{"location":"reference/#spector.vector.vector.values","title":"<code>values(dtype=float)</code>  <code>method descriptor</code>","text":"<p>Return values as numpy array.</p>"},{"location":"reference/#spector.matrix.matrix","title":"<code>spector.matrix.matrix</code>","text":"<p>               Bases: <code>defaultdict</code></p> <p>A sparse vector of vectors.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable</code> <code>()</code> Source code in <code>spector/matrix.py</code> <pre><code>class matrix(collections.defaultdict):\n    \"\"\"A sparse vector of vectors.\n\n    Args:\n        data (Iterable):\n    \"\"\"\n\n    def __init__(self, data=(), copy=True):\n        super().__init__(vector)\n        (self if copy else super()).update(data)\n\n    @classmethod\n    def cast(cls, data) -&gt; 'matrix':\n        return cls(data, copy=False)\n\n    @property\n    def row(self) -&gt; np.ndarray:\n        \"\"\"COO format row index array of the matrix\"\"\"\n        return np.concatenate([np.full(len(self[key]), key) for key in self])\n\n    @property\n    def col(self) -&gt; np.ndarray:\n        \"\"\"COO format column index array of the matrix\"\"\"\n        return np.concatenate([vec.keys() for vec in self.values()])\n\n    @property\n    def data(self) -&gt; np.ndarray:\n        \"\"\"COO format data array of the matrix\"\"\"\n        return np.concatenate([vec.values() for vec in self.values()])\n\n    def update(self, data):\n        \"\"\"Update from mapping or iterable.\"\"\"\n        if isinstance(data, Mapping):\n            for key in data:\n                self[key].update(data[key])\n        else:\n            for key, value in data:\n                self[key].update(value)\n\n    def __iadd__(self, other):\n        if isinstance(other, Mapping):\n            for key in other:\n                self[key] += other[key]\n        else:\n            self.map(vector.__iadd__, other)\n        return self\n\n    def __add__(self, other) -&gt; 'matrix':\n        return type(self)(self).__iadd__(other)\n\n    def __imul__(self, other):\n        if isinstance(other, Mapping):\n            for key in set(self).difference(other):\n                del self[key]\n            for key in self:\n                self[key] *= other[key]\n        else:\n            self.map(vector.__imul__, other)\n        return self\n\n    def __mul__(self, other) -&gt; dict:\n        if isinstance(other, Mapping):\n            return self.cast((key, self[key] * other[key]) for key in set(self).intersection(other))\n        return self.map(vector.__mul__, other)\n\n    def sum(self, axis: int | None = None):\n        \"\"\"Return sum of matrix elements across axis, by default both.\"\"\"\n        if axis in (0, -2):\n            return functools.reduce(vector.__iadd__, self.values(), vector())\n        if axis in (1, -1):\n            return self.map(np.sum)\n        if axis is None:\n            return sum(map(np.sum, self.values()))\n        raise np.exceptions.AxisError(axis, ndim=2)\n\n    def map(self, func: Callable, *args, **kwargs) -&gt; dict:\n        \"\"\"Return matrix with function applies across vectors.\"\"\"\n        result = {key: func(self[key], *args, **kwargs) for key in self}\n        if all(isinstance(value, vector) for value in result.values()):\n            return self.cast(result)\n        return result\n\n    def filter(self, func: Callable, *args, **kwargs) -&gt; 'matrix':\n        \"\"\"Return matrix with function applies across vectors.\"\"\"\n        return self.cast((key, vec) for key, vec in self.items() if func(vec, *args, **kwargs))\n\n    @classmethod\n    def fromcoo(cls, row: Iterable, col: Iterable[int], data: Iterable[float]) -&gt; 'matrix':\n        \"\"\"Return matrix from COOrdinate format arrays.\"\"\"\n        return cls.cast((key, vector(col, data)) for key, col, data in groupby(row, col, data))\n\n    def transpose(self) -&gt; 'matrix':\n        \"\"\"Return matrix with reversed dimensions.\"\"\"\n        return self.fromcoo(self.col, self.row, self.data)\n\n    T = property(transpose)\n\n    def __matmul__(self, other: 'matrix') -&gt; 'matrix':\n        other = other.transpose()\n        return self.cast((key, vector(other.map(self[key].__matmul__))) for key in self)\n</code></pre>"},{"location":"reference/#spector.matrix.matrix.col","title":"<code>col</code>  <code>property</code>","text":"<p>COO format column index array of the matrix</p>"},{"location":"reference/#spector.matrix.matrix.data","title":"<code>data</code>  <code>property</code>","text":"<p>COO format data array of the matrix</p>"},{"location":"reference/#spector.matrix.matrix.row","title":"<code>row</code>  <code>property</code>","text":"<p>COO format row index array of the matrix</p>"},{"location":"reference/#spector.matrix.matrix.filter","title":"<code>filter(func, *args, **kwargs)</code>","text":"<p>Return matrix with function applies across vectors.</p> Source code in <code>spector/matrix.py</code> <pre><code>def filter(self, func: Callable, *args, **kwargs) -&gt; 'matrix':\n    \"\"\"Return matrix with function applies across vectors.\"\"\"\n    return self.cast((key, vec) for key, vec in self.items() if func(vec, *args, **kwargs))\n</code></pre>"},{"location":"reference/#spector.matrix.matrix.fromcoo","title":"<code>fromcoo(row, col, data)</code>  <code>classmethod</code>","text":"<p>Return matrix from COOrdinate format arrays.</p> Source code in <code>spector/matrix.py</code> <pre><code>@classmethod\ndef fromcoo(cls, row: Iterable, col: Iterable[int], data: Iterable[float]) -&gt; 'matrix':\n    \"\"\"Return matrix from COOrdinate format arrays.\"\"\"\n    return cls.cast((key, vector(col, data)) for key, col, data in groupby(row, col, data))\n</code></pre>"},{"location":"reference/#spector.matrix.matrix.map","title":"<code>map(func, *args, **kwargs)</code>","text":"<p>Return matrix with function applies across vectors.</p> Source code in <code>spector/matrix.py</code> <pre><code>def map(self, func: Callable, *args, **kwargs) -&gt; dict:\n    \"\"\"Return matrix with function applies across vectors.\"\"\"\n    result = {key: func(self[key], *args, **kwargs) for key in self}\n    if all(isinstance(value, vector) for value in result.values()):\n        return self.cast(result)\n    return result\n</code></pre>"},{"location":"reference/#spector.matrix.matrix.sum","title":"<code>sum(axis=None)</code>","text":"<p>Return sum of matrix elements across axis, by default both.</p> Source code in <code>spector/matrix.py</code> <pre><code>def sum(self, axis: int | None = None):\n    \"\"\"Return sum of matrix elements across axis, by default both.\"\"\"\n    if axis in (0, -2):\n        return functools.reduce(vector.__iadd__, self.values(), vector())\n    if axis in (1, -1):\n        return self.map(np.sum)\n    if axis is None:\n        return sum(map(np.sum, self.values()))\n    raise np.exceptions.AxisError(axis, ndim=2)\n</code></pre>"},{"location":"reference/#spector.matrix.matrix.transpose","title":"<code>transpose()</code>","text":"<p>Return matrix with reversed dimensions.</p> Source code in <code>spector/matrix.py</code> <pre><code>def transpose(self) -&gt; 'matrix':\n    \"\"\"Return matrix with reversed dimensions.\"\"\"\n    return self.fromcoo(self.col, self.row, self.data)\n</code></pre>"},{"location":"reference/#spector.matrix.matrix.update","title":"<code>update(data)</code>","text":"<p>Update from mapping or iterable.</p> Source code in <code>spector/matrix.py</code> <pre><code>def update(self, data):\n    \"\"\"Update from mapping or iterable.\"\"\"\n    if isinstance(data, Mapping):\n        for key in data:\n            self[key].update(data[key])\n    else:\n        for key, value in data:\n            self[key].update(value)\n</code></pre>"},{"location":"reference/#spector.groupby","title":"<code>spector.groupby(keys, *arrays)</code>","text":"<p>Generate unique keys with associated groups.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Iterable</code> required <code>*arrays</code> <code>Iterable</code> <code>()</code> Source code in <code>spector/matrix.py</code> <pre><code>def groupby(keys: Iterable, *arrays) -&gt; Iterator[tuple]:\n    \"\"\"Generate unique keys with associated groups.\n\n    Args:\n        keys:\n        *arrays (Iterable):\n    \"\"\"\n    arrays = tuple(map(np.asarray, arrays))\n    try:\n        items = _arggroupby(asiarray(keys))\n    except TypeError:  # fallback to sorting\n        items = arggroupby(keys)\n    for key, values in items:\n        yield key, *(arr[values] for arr in arrays)\n</code></pre>"}]}